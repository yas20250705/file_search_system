### 仕様書：ローカルファイル全文検索システム 2025/07/06

このドキュメントは、Gemini CLIがローカルファイル全文検索システムを構築するための仕様を定義します。

#### 1. プロジェクト概要

指定されたローカルフォルダ内の多様な形式のファイル（PDF, Office文書, テキストファイル等）に対して、高速な全文検索機能を提供するWebアプリケーション。Web UIを通じて、検索対象のフォルダ設定、インデックス作成、キーワード検索、検索結果からのファイル起動を行うことができる。

#### 2. コア技術とライブラリ

-   **バックエンド:** Python 3
-   **Webフレームワーク:** FastAPI
-   **Webサーバー:** Uvicorn
-   **テンプレートエンジン:** Jinja2
-   **データベース:** SQLite 3
-   **ファイル解析ライブラリ:**
    -   PDF: `PyMuPDF`
    -   Excel: `openpyxl`
    -   Word: `python-docx`
    -   PowerPoint: `python-pptx`

#### 3. ファイル構成

最終的なプロジェクトのディレクトリ構造は以下の通りです。

```
/
├── main.py
├── database.py
├── indexer.py
├── templates/
│   ├── index.html
│   └── settings.html
├── static/
│   └── style.css
├── start_app.bat
└── @manual.txt
```

#### 4. コンポーネント別 詳細仕様

##### 4.1. `database.py` - データベース管理

**役割:**
SQLiteデータベースの接続、テーブルの作成、および各種データ操作機能を提供する。

**最重要仕様:**
-   **WAL (Write-Ahead Logging) モードの有効化:**
    -   インデックス作成（書き込み）と進捗確認（読み込み）の同時実行による `database is locked` エラーを防ぐため、データベース接続時に必ずWALモードを有効にすること。
    -   `PRAGMA journal_mode = WAL;` をテーブル作成の最初に実行する。
-   **FTS5テーブルの正しい定義:**
    -   全文検索用の仮想テーブル `files_fts` は、`snippet`関数を正しく利用するために、必ず `detail=full` オプション付きで作成すること。
    -   `files`テーブル（実データ）と`files_fts`テーブル（インデックス）を同期させるため、`content='files'` と `content_rowid='id'` オプションを指定すること。
-   **ロックの利用:**
    -   `meta_db_lock = threading.Lock()`: メタデータベースへのアクセスを保護する。
    -   `index_db_lock = threading.RLock()`: 個別インデックスデータベースへのアクセスを保護する。`RLock`を使用することで、同じスレッドからの複数回のロック取得を許可し、デッドロックを回避する。

**実装する関数:**
-   `get_meta_db_connection()`: メタデータベース接続を返す。
-   `get_index_db_connection(db_path: str)`: 指定されたインデックスデータベース接続を返す。
-   `initialize_meta_database()`: メタデータベースと必要なテーブルが存在しない場合にのみ初期化する。
-   `create_index_tables(db_path: str)`: 指定されたインデックスデータベース内に必要なテーブルが存在しない場合にのみ作成する。
-   `add_index_config(...)`: 新しいインデックス設定をメタデータベースに追加し、対応するDBファイルを作成する。
-   `get_all_index_configs()`: すべてのインデックス設定をメタデータベースから取得する。
-   `get_index_config_by_id(...)`: 指定されたIDのインデックス設定をメタデータベースから取得する。
-   `delete_index_config(...)`: 指定されたIDのインデックス設定と、関連するDBファイルを削除する。
-   `update_index_status(...)`: メタデータベース内のインデックスのステータスと最終インデックス作成日時を更新する。
-   `get_setting(conn, db_path: str, key: str)`: 個別インデックスデータベースから設定を取得する。
-   `set_setting(conn, db_path: str, key: str, value: str)`: 個別インデックスデータベースに設定を保存する。
-   `add_directory_to_history(conn, db_path: str, path: str)`: 個別インデックスデータベースにディレクトリ履歴を追加する。
-   `get_directory_history(conn, db_path: str)`: 個別インデックスデータベースからディレクトリ履歴を取得する。
-   `update_indexing_status(conn, db_path: str, ...)`: 個別インデックスデータベースのインデックス作成状況を更新する。
-   `get_indexing_status(conn, db_path: str)`: 個別インデックスデータベースのインデックス作成状況を取得する。
-   `set_indexing_stop_requested(conn, db_path: str, requested: bool)`: 個別インデックスデータベースに中止要求フラグを保存する。
-   `is_indexing_stop_requested(conn, db_path: str)`: 個別インデックスデータベースから中止要求フラグを取得する。

##### 4.2. `indexer.py` - インデックス作成処理

**役割:**
指定されたディレクトリを再帰的にスキャンし、許可された拡張子のファイルからテキストを抽出し、データベースに格納する。

**最重要仕様:**
-   **データベースへの正しい挿入ロジック:**
    -   `fts5: missing row ... from content table` エラーを防ぐため、データベースへの挿入は必ず以下の2ステップで行うこと。
        1.  まず、ファイルパスと抽出したテキストを `files` テーブルに `INSERT` する。
        2.  `cursor.lastrowid` を使って、直前に挿入した行の `id` を取得する。
        3.  取得した `id` を `rowid` として、`files_fts` テーブルに `INSERT` する。これにより、実データとインデックスが正しく紐づけられる。
-   **マルチスレッド対応:**
    -   この処理はFastAPIのメインスレッドをブロックしないよう、必ず別スレッド (`threading.Thread`) で実行すること。
-   **データベース接続の管理:**
    -   `index_files`関数内でデータベース接続を取得し、その接続を`update_indexing_status`などのデータベース操作関数に直接渡すことで、ロックの競合を最小限に抑える。
    -   関数終了時に接続を確実に閉じる。

**実装する関数:**
-   各種ファイルからのテキスト抽出関数 (`extract_text_from_pdf`, `extract_text_from_word` 等)。
-   `index_files(index_id: int, target_directory: str, allowed_extensions: list[str], db_path: str)`:
    -   インデックス作成のメインロジック。
    -   上記の**最重要仕様**（2ステップでのDB挿入）を必ず実装する。
    -   `update_indexing_status` を呼び出し、進捗状況を保存する。
    -   `is_indexing_stop_requested()` を定期的にチェックし、中止要求があれば処理を中断する。

##### 4.3. `main.py` - Webアプリケーション本体

**役割:**
FastAPIを用いてWebインターフェースを提供し、ユーザーからのリクエストに応じて各機能を呼び出す。

**実装するエンドポイント:**
-   `@app.on_event("startup")`:
    -   アプリケーション起動時に、すべてのインデックスのステータスをリセットする（以前の実行が予期せず終了した場合に 'running' ステータスが残るのを防ぐため）。
    -   各インデックスの個別DBテーブルが存在しない場合は作成する。
-   `/` (GET): 検索ページ (`index.html`) を表示する。
-   `/settings` (GET, POST): 設定ページ (`settings.html`) の表示と、設定の保存処理。
-   `/trigger_index_for_id/{index_id}` (GET): `indexer.py` の `index_files` を別スレッドで起動する。UIのリダイレクトではなく、非同期で処理を開始する。
-   `/stop_indexing_for_id/{index_id}` (GET): インデックス作成の中止フラグを立てる。
-   `/indexing_status_for_id/{index_id}` (GET): 現在のインデックス作成状況をJSONで返す。
-   `/search` (GET):
    -   検索クエリを受け取り、`files_fts` テーブルを検索する。
    -   **`snippet`関数を使用:** 検索結果のスニペット生成には、SQLite FTS5に組み込まれている `snippet` 関数を使用すること。
-   `/open` (GET): 指定されたファイルパスを、OSのデフォルトアプリケーションで開く (`os.startfile`)。

##### 4.4. `templates/` - HTMLテンプレート

-   **`index.html`**:
    -   検索フォーム。
    -   検索結果をループで表示するエリア。ファイルパスとスニペットを表示する。
    -   ファイルパスは `/open` エンドポイントへのリンクにする。
-   **`settings.html`**:
    -   検索対象ディレクトリを入力するフォーム。
    -   許可する拡張子をチェックボックスで選択するフォーム。
    -   インデックス作成の開始・停止ボタン。
    -   インデックス作成の進捗状況を表示するエリア（JavaScriptで `/indexing_status_for_id` を定期的にポーリングして更新する）。
    -   インデックス作成ボタンクリック時にページがリダイレクトされないように、`fetch` APIを使用して非同期でバックエンドを呼び出す。

##### 4.5. `static/style.css`

-   アプリケーション全体に適用するシンプルなCSS。可読性を重視した最低限のスタイリングで良い。

##### 4.6. `start_app.bat` - 起動用バッチファイル

**役割:**
ダブルクリックで簡単にアプリケーションを起動できるようにする。

**仕様:**
-   `@echo off` で開始する。
-   `call .\myenv\Scripts\activate` で仮想環境を有効化する。
-   `uvicorn main:app --reload` でサーバーを起動する。
-   `pause` を最後に入れることで、エラー時にウィンドウがすぐに閉じてしまうのを防ぐ。
-   **注意:** ブラウザの自動起動は環境依存で失敗しやすいため、実装せず、ユーザーに手動でアクセスするよう促すコメントを記載するに留める。

##### 4.7. `@manual.txt` - 取扱説明書

-   本アプリケーションの概要、起動方法、設定・インデックス作成・検索方法を記載した平易なテキストファイル。